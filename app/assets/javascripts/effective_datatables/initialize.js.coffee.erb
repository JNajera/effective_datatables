initializeDataTables = ->
  $('table[data-effective-datatables-table]').each ->
    unless $.fn.DataTable.fnIsDataTable(this)
      datatable = $(this)

      init_options =
        ajax: { url: datatable.data('source'), type: 'POST' }
        autoWidth: false
        processing: true
        deferRender: true
        serverSide: true
        scrollCollapse: true
        deferLoading: [datatable.data('display-records'), datatable.data('total-records')] # fixedColumns won't work with deferLoading
        pagingType: 'simple_numbers'
        buttons: [
          {
            extend: 'colvis',
            text: 'Show / hide columns',
            postfixButtons: [
              { extend: 'colvisGroup', text: 'Show all', show: ':hidden'},
              { extend: 'colvisRestore', text: 'Show default'}
            ]
          }, 'copy', 'csv', 'excel', 'print'
        ]
        language: { 'lengthMenu': 'Show _MENU_ per page'}
        lengthMenu: [[10, 25, 50, 100, 250, 1000, -1], ['10', '25', '50', '100', '250', '1000', 'All']]
        iDisplayLength: datatable.data('display-entries')
        columnDefs: [
          { visible: false, targets: datatable.data('non-visible') },
          { sortable: false, targets: datatable.data('non-sortable') }
        ].concat(datatable.data('column-classes') || []).concat(datatable.data('column-names') || [])
        order: datatable.data('default-order')
        serverParams: (params) ->
          table = this.DataTable()
          table.columns().flatten().each (index) =>  # Pass which columns are visible back to server
            params['columns'][index]['visible'] = table.column(index).visible()

      if datatable.data('effective-datatables-table') == 'simple'
        init_options['lengthMenu'] = [-1] # Show all results
        init_options['dom'] = "<'row'r>t" # Just show the table

      # Initialize Searching
      dataTableSearch = (event) ->   # This is the function called by a select or input to run the search
        obj = $(event.currentTarget)
        table = obj.closest('table.dataTable')

        # We're using our own scroll wrapper, not the ScrollX support
        if table.parent().hasClass('dataTables_scrollHeadInner') # ScrollX support
          table = table.closest('.dataTables_scroll').children('.dataTables_scrollBody').children('table.dataTable')
        table.DataTable().column("#{obj.data('column-name')}:name").search(obj.val()).draw()

      # For every existing Input, Set up the search events
      search_inputs = datatable.find('thead').first().find('input,select')

      search_inputs.each (index, input) ->
        $input = $(input)

        if $input.data('column-name')
          $input.parent().on 'click', (event) -> false # Dont order columns when you click inside the input
          $input.parent().on 'mousedown', (event) -> event.stopPropagation() # Dont order columns when you click inside the input

          if $input.is('select')
            $input.on 'change', (event) -> dataTableSearch(event)
          else if $input.is('input')
            $input.keyup($.debounce(300, dataTableSearch))

      # Let's actually initialize the table now
      table = datatable.dataTable(init_options)

      # Assign PreSearch columns
      search_inputs.each (index, input) =>
        $input = $(input)
        if $input.data('column-index') && $input.data('column-name') && $input.val()
          table.fnSettings().aoPreSearchCols[$input.data('column-index')].sSearch = $input.val()

      # FixedColumns doesn't work well yet.
      # fixedColumns = new $.fn.dataTable.FixedColumns(table,
      #  leftColumns: 2
      # )

      # Apply EffectiveFormInputs to the Show x per page dropdown
      if datatable.data('effective-form-inputs')
        table.closest('.dataTables_wrapper').find('.dataTables_length select').select2()

      # Capture column visibility changes and refresh datatable
      datatable.on 'column-visibility.dt', (event, settings, index, state) ->
        $table = $(event.currentTarget)

        timeout = $table.data('timeout')
        clearTimeout(timeout) if timeout
        $table.data('timeout', setTimeout( =>
            $table.DataTable().draw()
            $.event.trigger('page:change')
          , 1000)
        )

      # new $.fn.dataTable.ColReorder(table)

$ -> initializeDataTables()
$(document).on 'page:change', -> initializeDataTables()

